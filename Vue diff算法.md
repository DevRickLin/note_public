#wip #vue #frontend #性能

https://juejin.cn/post/7148412376637767711
https://juejin.cn/post/7092068900589797413

	在 vue2 中是通过对旧节点列表建立一个 { key, oldVnode }的映射表，然后遍历新节点列表的剩余节点，根据newVnode.key在旧映射表中寻找可复用的节点，然后打补丁并且移动到正确的位置。  
	  
	而在 vue3 中是建立一个存储新节点数组中的剩余节点在旧节点数组上的索引的映射关系数组，建立完成这个数组后也即找到了可复用的节点，然后通过这个数组计算得到最长递增子序列，这个序列中的节点保持不动，然后将新节点数组中的剩余节点移动到正确的位置。

# Vue3 快速diff
1. 目标是在最小的移动操作下，将旧节点数组变为新节点
2. 只要找到最小递增子序列，接着倒序遍历旧数组，遇到子序列内元素不动，子序列外元素移动即可
3. 实现方式的基本原理是贪心+二分查找

## 算法基本流程

1. 假如当前元素比结果数组最后一位大，直接加入结果
3. 如果比结果下，二分查找刚好大于其的元素，如果该元素比当前元素大，进行替换
4. 时间复杂度O(nlogn)
5. 复用最长递增子序列，用对序列外元素进行移动。

https://juejin.cn/post/7081621840187097119